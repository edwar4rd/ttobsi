---
tags: 個研, graphic
---

# [進度]20220209 專題紀錄

## 專題趕工囉！

欸不是我怎麼混一混就快開學了

## 再確認一次程式要幹嘛

- 編輯光源、吸光的擋板、真實透鏡、薄透鏡、凹凸面鏡
- 模擬光源射出光線後與其他物鏡的互動
  - 反射
  - 透射
- 就這樣剩下的再說

## 程式架構

因為最後我決定使用 SDL (Simple DirectMedia Layer) 函式庫以得到較好的跨平台性並使用 C++，我的主程式會包含讀取可能有的參數並初始化以及主要的事件迴圈兩個階段，並先以單執行緒為主。

```c++
<<*>>=
<<Include Header Files>>
<<Declare Global Values>>
<<Function Declarations>>
int main(int argc, char **argv) {
    <<Process Arguments>>
    <<Initialization>>
    <<Event Loop Varibles>>
    <<Main Event Loop>>
    <<Cleanup>>
}
@
```

## 顯示架構

SDL 的顯示主要有兩種，一種是使用 CPU 的軟體渲染，另一種則是可以使用 GPU 加速的硬體渲染。

使用 CPU 的軟體渲染主要使用 `SDL_Surface` 結構，
這個結構包含一塊像素平面，可以被程式直接存取、更改。
我們可以使用 `SDL_GetWindowSurface` 得到視窗的像素平面，
更改內容後再使用 `SDL_UpdateWindowSurface` 將讓視窗顯示我們剛剛得到並可能更改過的平面。
此外，我們也可以使用 `SDL_LoadBMP` 或是 `SDL_Image` 的 `IMG_Load` 將圖片檔案存成 `SDL_Surface` 的形式，
並使用 `SDL_BlitSurface` 將圖片貼到視窗上。

使用 GPU 加速的渲染則使用 `SDL_Renderer` 和 `SDL_Texture` ，
其中 `SDL_Renderer` 可以儲存對應到我們的視窗的渲染器，使用函式如 `SDL_RenderFillRect`，
`SDL_RenderDrawPoint` 可以叫一個渲染器畫出一個長方形或像素，
但是我們無法直接用（記憶體）存取的方式更改螢幕上的像素。
另外我們使用渲染器畫的內容實際上是畫在一個暫存器中的，
因此畫完之後必須使用 `SDL_RenderPresent` 將我們畫的內容放上螢幕，
但在這之後暫存器的內容就無法保證是什麼了，
因此必須調用 `SDL_RenderClear` 清空(用顏色填滿)暫存器，並重新畫所有內容
。

`SDL_Texture` 有點類似 `SDL_Surface`，但是他的資料是儲存在渲染器端的，
因此不能被 CPU 存取但可以被渲染器貼到螢幕上使用。
此外，我們可以將 `SDL_Surface` 轉成 `SDL_Texture`，
就可以將 CPU 渲染的結果和電腦檔案中的圖片與 `SDL_Renderer` 一起使用了。

## 顯示架構和分層

根據前述

- `SDL_RenderClear()`: 將暫存器清空並將背景設為一定顏色(可能是黑色，但也可以是其他顏色)
- 場景中的各個物件，如鏡面、障礙物等
- 上述物件被照亮的部份，可能是以半透明材質貼圖的方式呈現，並部份由檔案讀取或使用 CPU 進行計算
- 要突顯的光路，使用明顯的顏色方便觀察
- 編輯場景時標出編輯物件或參數的提示，如物件外框、控制點位置、輔助線等。

## 事件迴圈

一個事件迴圈是指一個程式會重複執行，並在迴圈中處理使用者輸入的事件並進行相應處理，最後當程式退出這一階段時才結束的迴圈。

我們可以使用一個變數紀錄是否要還沒退出迴圈，並當這個變數為真時都重複執行事件迴圈內的內容。

此外事件迴圈中需要處理使用者對程式輸入的事件，
如滑鼠、鍵盤等，我們可以調用 `SDL_PollEvent(&e)`在 `SDL_Event e;` 中存入下一個未被存取過的事件，並根據 `e` 的內容進行處理。
但是我們的程式中大部分的事件都會跟我們的物件以及先前的事件有關，所以我將這些事件的處理單獨拉到一個函數處理。

這個函數可以用類似事件驅動有限狀態機的方式表示，並會跟據輸入的事件 `e` 修改一個場景中物件的列表，和編輯編輯器圖層所需要顯示的物件的列表。

接下來迴圈中還需要處理所有的渲染，包含場景的運算。
因為每次場景運算時會調用 `SDL_RenderClear` ，
不需要每次重新計算的渲染物件需要另外儲存方便後面重新顯示到螢幕上
